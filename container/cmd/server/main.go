package main

import (
	"log"
	"os"
	"strings"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/swagger"
	_ "github.com/vanpelt/catnip/docs" // This will be generated by swag
	"github.com/vanpelt/catnip/internal/handlers"
	"github.com/vanpelt/catnip/internal/models"
	"github.com/vanpelt/catnip/internal/services"
)

// @title Catnip Container API
// @version 1.0
// @description API for managing container PTY sessions and services
// @host localhost:8080
// @schemes http ws
func main() {
	// Start settings persistence manager
	settings := models.NewSettings()
	settings.Start()
	defer settings.Stop()

	// Initialize Git service
	gitService := services.NewGitService()
	defer gitService.Stop()

	// Initialize Git HTTP service
	gitHTTPService := services.NewGitHTTPService(gitService)

	// Initialize port monitoring service
	portMonitor := services.NewPortMonitor()
	defer portMonitor.Stop()

	// Check CATNIP_REPO environment variable
	if catnipRepo := os.Getenv("CATNIP_REPO"); catnipRepo != "" {
		log.Printf("üåü CATNIP_REPO detected: %s", catnipRepo)
		go func() {
			// Parse CATNIP_REPO format: github.com/owner/repo[@branch]
			parts := strings.Split(catnipRepo, "@")
			repoParts := strings.Split(strings.TrimPrefix(parts[0], "github.com/"), "/")
			if len(repoParts) >= 2 {
				org := repoParts[0]
				repo := strings.Join(repoParts[1:], "/")
				branch := ""
				if len(parts) > 1 {
					branch = parts[1]
				}

				log.Printf("üì¶ Auto-checkout: %s/%s (branch: %s)", org, repo, branch)
				if _, _, err := gitService.CheckoutRepository(org, repo, branch); err != nil {
					log.Printf("‚ùå Failed to checkout repository: %v", err)
				}
			}
		}()
	}

	app := fiber.New(fiber.Config{
		DisableStartupMessage: false,
		AppName:               "Catnip Container v1.0.0",
	})

	// Middleware
	app.Use(logger.New())
	app.Use(recover.New())
	app.Use(cors.New(cors.Config{
		AllowOrigins: "*",
		AllowHeaders: "Origin, Content-Type, Accept",
	}))

	// Health check
	app.Get("/health", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"status": "ok"})
	})

	// Swagger documentation
	app.Get("/swagger/*", swagger.HandlerDefault)

	// Register Git HTTP routes (must be before other routes to catch .git URLs)
	gitHTTPService.RegisterRoutes(app)

	// API v1 routes
	v1 := app.Group("/v1")

	// Initialize services
	claudeService := services.NewClaudeService()
	anthropicService := services.NewAnthropicService()

	// Initialize handlers
	ptyHandler := handlers.NewPTYHandler(gitService)
	authHandler := handlers.NewAuthHandler()
	uploadHandler := handlers.NewUploadHandler()
	gitHandler := handlers.NewGitHandler(gitService, gitHTTPService)
	claudeHandler := handlers.NewClaudeHandler(claudeService)
	anthropicHandler := handlers.NewAnthropicHandler(anthropicService)
	sessionHandler := handlers.NewSessionsHandler(ptyHandler.GetSessionService(), claudeService)
	portsHandler := handlers.NewPortsHandler(portMonitor)
	proxyHandler := handlers.NewProxyHandler(portMonitor)

	// Register routes
	v1.Get("/pty", ptyHandler.HandleWebSocket)

	// Auth routes
	v1.Post("/auth/github/start", authHandler.StartGitHubAuth)
	v1.Get("/auth/github/status", authHandler.GetAuthStatus)

	// Upload routes
	v1.Post("/upload", uploadHandler.UploadFile)

	// Git routes
	v1.Post("/git/checkout/:org/:repo", gitHandler.CheckoutRepository)
	v1.Get("/git/status", gitHandler.GetStatus)
	v1.Get("/git/worktrees", gitHandler.ListWorktrees)
	v1.Delete("/git/worktrees/:id", gitHandler.DeleteWorktree)
	v1.Post("/git/worktrees/:id/sync", gitHandler.SyncWorktree)
	v1.Get("/git/worktrees/:id/sync/check", gitHandler.CheckSyncConflicts)
	v1.Post("/git/worktrees/:id/merge", gitHandler.MergeWorktreeToMain)
	v1.Get("/git/worktrees/:id/merge/check", gitHandler.CheckMergeConflicts)
	v1.Get("/git/worktrees/:id/diff", gitHandler.GetWorktreeDiff)
	v1.Post("/git/worktrees/:id/preview", gitHandler.CreateWorktreePreview)
	v1.Post("/git/worktrees/:id/pr", gitHandler.CreatePullRequest)
	v1.Get("/git/github/repos", gitHandler.ListGitHubRepositories)
	v1.Get("/git/branches/:repo_id", gitHandler.GetRepositoryBranches)

	// Claude routes
	v1.Get("/claude/session", claudeHandler.GetWorktreeSessionSummary)
	v1.Get("/claude/session/:uuid", claudeHandler.GetSessionByUUID)
	v1.Get("/claude/sessions", claudeHandler.GetAllWorktreeSessionSummaries)

	// Anthropic API routes
	v1.Post("/anthropic/messages", anthropicHandler.CreateMessage)

	// Session management routes
	v1.Get("/sessions/active", sessionHandler.GetActiveSessions)
	v1.Get("/sessions", sessionHandler.GetAllSessions)
	v1.Get("/sessions/workspace/:workspace", sessionHandler.GetSessionByWorkspace)
	v1.Get("/sessions/workspace/:workspace/session/:sessionId", sessionHandler.GetSessionById)
	v1.Delete("/sessions/workspace/:workspace", sessionHandler.DeleteSession)

	// Port monitoring routes
	v1.Get("/ports", portsHandler.GetPorts)
	v1.Get("/ports/:port", portsHandler.GetPortInfo)

	// Proxy routes for detected services (must be before dev middleware)
	// Will validate port numbers in handler and call Next() if invalid
	app.Get("/:port", proxyHandler.ProxyToPort)
	app.Get("/:port/*", proxyHandler.ProxyToPort)

	// Handle static files and SPA routing
	if handlers.IsDevMode() {
		// In development mode, proxy to Vite dev server
		log.Println("üîß Development mode: proxying to Vite dev server")
		app.Use(func(c *fiber.Ctx) error {
			// Skip API routes and health/swagger
			path := c.Path()
			if path == "/health" ||
				strings.HasPrefix(path, "/swagger") ||
				strings.HasPrefix(path, "/v1/") {
				return c.Next()
			}
			// Port proxy routes are handled above with regex constraints
			// Proxy everything else to Vite
			return handlers.ProxyToVite(c)
		})
	} else {
		// Production mode: serve static files
		staticPath := os.Getenv("STATIC_PATH")
		if staticPath == "" {
			staticPath = "./dist"
		}

		app.Static("/", staticPath)

		// Fallback to index.html for SPA routing
		app.Get("/*", func(c *fiber.Ctx) error {
			return c.SendFile(staticPath + "/index.html")
		})
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("üöÄ Catnip server starting on port %s", port)
	log.Fatal(app.Listen(":" + port))
}
