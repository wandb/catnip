package cmd

import (
	"os"
	"strings"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/swagger"
	"github.com/spf13/cobra"
	_ "github.com/vanpelt/catnip/docs" // This will be generated by swag
	"github.com/vanpelt/catnip/internal/config"
	"github.com/vanpelt/catnip/internal/handlers"
	"github.com/vanpelt/catnip/internal/logger"
	"github.com/vanpelt/catnip/internal/models"
	"github.com/vanpelt/catnip/internal/services"
)

var serveCmd = &cobra.Command{
	Use:    "serve",
	Short:  "üöÄ Start the Catnip server",
	Hidden: true,
	Long: `Start the Catnip HTTP/WebSocket server.

This command starts the main Catnip server that provides:
- üñ•Ô∏è  Web interface for container management
- üîå WebSocket PTY sessions for terminal access
- üìä Real-time port monitoring and proxying
- üìÅ Git repository and worktree management
- ü§ñ Claude AI integration for development assistance

The server will automatically detect and proxy to running services on different ports.`,
	Run: func(cmd *cobra.Command, args []string) {
		startServer(cmd)
	},
}

func init() {
	rootCmd.AddCommand(serveCmd)

	// Add port flag
	serveCmd.Flags().StringP("port", "p", "6369", "Port to listen on")
}

// @title Catnip Container API
// @version 1.0
// @description API for managing container PTY sessions and services
// @host localhost:6369
// @schemes http ws
func startServer(cmd *cobra.Command) {
	// Configure logging with formatted output (always use console formatting to match Fiber)
	// Check CATNIP_DEV which is set by the run command in dev mode
	isDevMode := os.Getenv("CATNIP_DEV") == "true"
	logLevel := logger.GetLogLevelFromEnv(isDevMode)
	logger.Configure(logLevel, true) // Always use formatted output

	// Import and log runtime configuration
	logger.Infof("üöÄ Starting Catnip in %s mode", config.Runtime.Mode)
	if config.Runtime.IsNative() {
		logger.Debugf("üìÅ Workspace: %s", config.Runtime.WorkspaceDir)
		logger.Debugf("‚öôÔ∏è  Config: %s", config.Runtime.VolumeDir)
		if config.Runtime.CurrentRepo != "" {
			logger.Debugf("üì¶ Current repo: %s", config.Runtime.CurrentRepo)
		}
	}

	// Start settings persistence manager in containerized environments
	var settings *models.Settings
	if config.Runtime.IsContainerized() {
		settings = models.NewSettings()
		settings.Start()
		defer settings.Stop()
	}

	// Initialize Git service (but don't defer Stop() yet, as we need to set up dependencies first)
	gitService := services.NewGitService()
	defer gitService.Stop()

	// Initialize Git HTTP service
	gitHTTPService := services.NewGitHTTPService(gitService)

	// Initialize port monitoring service
	portMonitor := services.NewPortMonitor()
	defer portMonitor.Stop()

	// Check CATNIP_REPO environment variable
	if catnipRepo := os.Getenv("CATNIP_REPO"); catnipRepo != "" {
		logger.Infof("üåü CATNIP_REPO detected: %s", catnipRepo)
		go func() {
			// Parse CATNIP_REPO format: github.com/owner/repo[@branch]
			parts := strings.Split(catnipRepo, "@")
			repoParts := strings.Split(strings.TrimPrefix(parts[0], "github.com/"), "/")
			if len(repoParts) >= 2 {
				org := repoParts[0]
				repo := strings.Join(repoParts[1:], "/")
				branch := ""
				if len(parts) > 1 {
					branch = parts[1]
				}

				logger.Infof("üì¶ Auto-checkout: %s/%s (branch: %s)", org, repo, branch)
				if _, _, err := gitService.CheckoutRepository(org, repo, branch); err != nil {
					logger.Errorf("‚ùå Failed to checkout repository: %v", err)
				}
			}
		}()
	}

	app := fiber.New(fiber.Config{
		DisableStartupMessage: false,
		AppName:               "Catnip Container v1.0.0",
	})

	// Middleware
	app.Use(handlers.SamplingLogger())
	app.Use(recover.New())
	app.Use(cors.New(cors.Config{
		AllowOrigins: "*",
		AllowHeaders: "Origin, Content-Type, Accept",
	}))

	// Health check
	app.Get("/health", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"status": "ok"})
	})

	// Settings endpoint - returns environment configuration
	app.Get("/v1/settings", func(c *fiber.Ctx) error {
		catnipProxy := os.Getenv("CATNIP_PROXY")
		codespaceName := os.Getenv("CODESPACE_NAME")
		return c.JSON(fiber.Map{
			"catnipProxy":   catnipProxy,
			"authRequired":  catnipProxy != "",
			"codespaceName": codespaceName,
			"isCodespace":   codespaceName != "",
		})
	})

	// Swagger documentation
	app.Get("/swagger/*", swagger.HandlerDefault)

	// Register Git HTTP routes (must be before other routes to catch .git URLs)
	gitHTTPService.RegisterRoutes(app)

	// API v1 routes
	v1 := app.Group("/v1")

	// Initialize services
	claudeService := services.NewClaudeService()
	sessionService := services.NewSessionService()

	// Initialize and start Claude monitor service
	claudeMonitor := services.NewClaudeMonitorService(gitService, sessionService, claudeService, gitService.GetStateManager())

	// Initialize handlers
	ptyHandler := handlers.NewPTYHandler(gitService, claudeMonitor, sessionService, portMonitor)

	// Wire up the setup executor to enable setup.sh execution in new worktrees
	logger.Debugf("üîß Setting up setupExecutor for gitService")
	gitService.SetSetupExecutor(ptyHandler)
	logger.Debugf("‚úÖ setupExecutor configured successfully")

	// Wire up the claude monitor to git service
	gitService.SetClaudeMonitor(claudeMonitor)

	// Restore state from persistent storage before initializing repos
	logger.Debugf("üîÑ Restoring worktree state from persistent storage")
	if err := gitService.RestoreState(); err != nil {
		logger.Debugf("‚ö†Ô∏è  Failed to restore state: %v", err)
	}

	// Clean up orphaned catnip refs on startup
	logger.Debugf("üßπ Running startup cleanup of orphaned catnip refs")
	gitService.CleanupAllCatnipRefs()

	// Now initialize local repositories with setup executor properly configured
	gitService.InitializeLocalRepos()
	if err := claudeMonitor.Start(); err != nil {
		logger.Debugf("‚ö†Ô∏è  Failed to start Claude monitor service: %v", err)
	} else {
		logger.Debugf("‚úÖ Claude monitor service started successfully")
	}
	defer claudeMonitor.Stop()

	authHandler := handlers.NewAuthHandler()
	uploadHandler := handlers.NewUploadHandler()
	gitHandler := handlers.NewGitHandler(gitService, gitHTTPService, sessionService, claudeMonitor)
	sessionHandler := handlers.NewSessionsHandler(sessionService, claudeService)
	eventsHandler := handlers.NewEventsHandler(portMonitor, gitService)
	claudeHandler := handlers.NewClaudeHandler(claudeService, gitService).WithEvents(eventsHandler)
	defer eventsHandler.Stop()
	portsHandler := handlers.NewPortsHandler(portMonitor).WithEvents(eventsHandler)
	proxyHandler := handlers.NewProxyHandler(portMonitor)

	// Connect events handler to GitService for worktree status events
	gitService.SetEventsHandler(eventsHandler)
	logger.Debugf("‚úÖ EventsHandler connected to GitService for worktree cache events")

	// Connect events handler to SessionService for session title events
	sessionService.SetEventsHandler(eventsHandler)
	logger.Debugf("‚úÖ EventsHandler connected to SessionService for session title events")

	// Connect SessionService to GitService for Claude activity state tracking
	gitService.SetSessionService(sessionService)
	logger.Debugf("‚úÖ SessionService connected to GitService for Claude activity state tracking")

	// Connect ClaudeMonitorService to SessionService for real-time activity tracking
	sessionService.SetClaudeMonitor(claudeMonitor)
	logger.Debugf("‚úÖ ClaudeMonitorService connected to SessionService for real-time activity tracking")

	// Register routes
	v1.Get("/pty", ptyHandler.HandleWebSocket)

	// Auth routes
	v1.Post("/auth/github/start", authHandler.StartGitHubAuth)
	v1.Get("/auth/github/status", authHandler.GetAuthStatus)
	v1.Post("/auth/github/reset", authHandler.ResetAuthState)

	// Upload routes
	v1.Post("/upload", uploadHandler.UploadFile)

	// Git routes
	v1.Post("/git/checkout/:org/:repo", gitHandler.CheckoutRepository)
	v1.Get("/git/status", gitHandler.GetStatus)
	v1.Get("/git/worktrees", gitHandler.ListWorktrees)
	v1.Patch("/git/worktrees/:id", gitHandler.UpdateWorktree)
	v1.Delete("/git/worktrees/:id", gitHandler.DeleteWorktree)
	v1.Post("/git/worktrees/cleanup", gitHandler.CleanupMergedWorktrees)
	v1.Post("/git/worktrees/:id/sync", gitHandler.SyncWorktree)
	v1.Get("/git/worktrees/:id/sync/check", gitHandler.CheckSyncConflicts)
	v1.Post("/git/worktrees/:id/merge", gitHandler.MergeWorktreeToMain)
	v1.Get("/git/worktrees/:id/merge/check", gitHandler.CheckMergeConflicts)
	v1.Get("/git/worktrees/:id/diff", gitHandler.GetWorktreeDiff)
	v1.Post("/git/worktrees/:id/preview", gitHandler.CreateWorktreePreview)
	v1.Post("/git/worktrees/:id/pr", gitHandler.CreatePullRequest)
	v1.Put("/git/worktrees/:id/pr", gitHandler.UpdatePullRequest)
	v1.Get("/git/worktrees/:id/pr", gitHandler.GetPullRequestInfo)
	v1.Post("/git/worktrees/:id/graduate", gitHandler.GraduateBranch)
	v1.Post("/git/worktrees/:id/refresh", gitHandler.RefreshWorktreeStatus)
	v1.Get("/git/github/repos", gitHandler.ListGitHubRepositories)
	v1.Post("/git/repositories/:id/github", gitHandler.CreateGitHubRepository)
	v1.Get("/git/branches/:repo_id", gitHandler.GetRepositoryBranches)
	v1.Post("/git/template", gitHandler.CreateFromTemplate)

	// Claude routes
	v1.Get("/claude/session", claudeHandler.GetWorktreeSessionSummary)
	v1.Get("/claude/session/:uuid", claudeHandler.GetSessionByUUID)
	v1.Get("/claude/sessions", claudeHandler.GetAllWorktreeSessionSummaries)
	v1.Get("/claude/todos", claudeHandler.GetWorktreeTodos)
	v1.Get("/claude/latest-message", claudeHandler.GetWorktreeLatestAssistantMessage)
	v1.Post("/claude/messages", claudeHandler.CreateCompletion)
	v1.Get("/claude/settings", claudeHandler.GetClaudeSettings)
	v1.Put("/claude/settings", claudeHandler.UpdateClaudeSettings)
	v1.Post("/claude/hooks", claudeHandler.HandleClaudeHook)

	// Session management routes
	v1.Get("/sessions/active", sessionHandler.GetActiveSessions)
	v1.Get("/sessions", sessionHandler.GetAllSessions)
	v1.Get("/sessions/workspace/:workspace", sessionHandler.GetSessionByWorkspace)
	v1.Get("/sessions/workspace/:workspace/session/:sessionId", sessionHandler.GetSessionById)
	v1.Delete("/sessions/workspace/:workspace", sessionHandler.DeleteSession)

	// Port monitoring routes
	v1.Get("/ports", portsHandler.GetPorts)
	v1.Get("/ports/:port", portsHandler.GetPortInfo)
	v1.Post("/ports/mappings", portsHandler.SetPortMapping)
	v1.Delete("/ports/mappings/:port", portsHandler.DeletePortMapping)

	// Server info route
	v1.Get("/info", func(c *fiber.Ctx) error {
		commit, date, builtBy := GetBuildInfo()
		return c.JSON(fiber.Map{
			"version": GetVersion(),
			"build": fiber.Map{
				"commit":  commit,
				"date":    date,
				"builtBy": builtBy,
			},
		})
	})

	// Events routes
	v1.Get("/events", eventsHandler.HandleSSE)

	// Notification routes
	notificationHandler := handlers.NewNotificationHandler(eventsHandler)
	v1.Post("/notifications", notificationHandler.HandleNotification)

	// Proxy routes for detected services (must be before dev middleware)
	// Will validate port numbers in handler and call Next() if invalid
	app.All("/:port", proxyHandler.ProxyToPort)
	app.All("/:port/*", proxyHandler.ProxyToPort)

	// Handle static files and SPA routing
	if handlers.IsDevMode() {
		// In development mode, proxy to Vite dev server
		logger.Infof("üîß Development mode: proxying to Vite dev server %s", handlers.ViteServerURL())
		app.Use(func(c *fiber.Ctx) error {
			// Skip API routes and health/swagger
			path := c.Path()
			if path == "/health" ||
				strings.HasPrefix(path, "/swagger") ||
				strings.HasPrefix(path, "/v1/") {
				return c.Next()
			}
			// Port proxy routes are handled above with regex constraints
			// Proxy everything else to Vite
			return handlers.ProxyToVite(c)
		})
	} else {
		// Production mode: serve embedded static files or fallback to external
		if handlers.HasEmbeddedAssets() {
			logger.Infof("üöÄ Production mode: serving embedded frontend assets")

			// Serve embedded static files
			app.Use("/", handlers.ServeEmbeddedAssets())

			// Fallback to index.html for SPA routing (embedded)
			app.Get("/*", handlers.ServeEmbeddedSPA)
		} else {
			// Fallback to external static files if assets not embedded
			logger.Infof("‚ö†Ô∏è  Production mode: frontend assets not embedded, serving from ./dist")
			staticPath := os.Getenv("STATIC_PATH")
			if staticPath == "" {
				staticPath = "./dist"
			}

			app.Static("/", staticPath)

			// Fallback to index.html for SPA routing
			app.Get("/*", func(c *fiber.Ctx) error {
				return c.SendFile(staticPath + "/index.html")
			})
		}
	}

	// Get port from flag or environment variable
	port, _ := cmd.Flags().GetString("port")
	if envPort := os.Getenv("PORT"); envPort != "" {
		port = envPort
	}

	logger.Infof("üöÄ Catnip server starting on port %s", port)
	if err := app.Listen(":" + port); err != nil {
		logger.Fatalf("Server failed to start on port %s: %v", port, err)
	}
}
