// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../../../time/models.js";

/**
 * ClaudeActivityState represents the current activity state of a Claude session
 * @readonly
 * @enum {string}
 */
export const ClaudeActivityState = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: "",

    /**
     * ClaudeInactive means no Claude session exists
     */
    ClaudeInactive: "inactive",

    /**
     * ClaudeRunning means PTY session exists but no recent Claude activity (>2 minutes)
     */
    ClaudeRunning: "running",

    /**
     * ClaudeActive means recent Claude activity detected (<2 minutes)
     */
    ClaudeActive: "active",
};

/**
 * ClaudeHistoryEntry represents an entry in the Claude history
 */
export class ClaudeHistoryEntry {
    /**
     * Creates a new ClaudeHistoryEntry instance.
     * @param {Partial<ClaudeHistoryEntry>} [$$source = {}] - The source object to create the ClaudeHistoryEntry.
     */
    constructor($$source = {}) {
        if (!("display" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["display"] = "";
        }
        if (!("pastedContents" in $$source)) {
            /**
             * @member
             * @type {{ [_: string]: any }}
             */
            this["pastedContents"] = {};
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClaudeHistoryEntry instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ClaudeHistoryEntry}
     */
    static createFrom($$source = {}) {
        const $$createField1_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("pastedContents" in $$parsedSource) {
            $$parsedSource["pastedContents"] = $$createField1_0($$parsedSource["pastedContents"]);
        }
        return new ClaudeHistoryEntry(/** @type {Partial<ClaudeHistoryEntry>} */($$parsedSource));
    }
}

/**
 * ClaudeSessionMessage represents a message in a Claude session file
 */
export class ClaudeSessionMessage {
    /**
     * Creates a new ClaudeSessionMessage instance.
     * @param {Partial<ClaudeSessionMessage>} [$$source = {}] - The source object to create the ClaudeSessionMessage.
     */
    constructor($$source = {}) {
        if (!("cwd" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["cwd"] = "";
        }
        if (!("isMeta" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["isMeta"] = false;
        }
        if (!("isSidechain" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["isSidechain"] = false;
        }
        if (!("message" in $$source)) {
            /**
             * @member
             * @type {{ [_: string]: any }}
             */
            this["message"] = {};
        }
        if (!("parentUuid" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["parentUuid"] = "";
        }
        if (!("sessionId" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["sessionId"] = "";
        }
        if (!("timestamp" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["timestamp"] = "";
        }
        if (!("type" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["type"] = "";
        }
        if (!("userType" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["userType"] = "";
        }
        if (!("uuid" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["uuid"] = "";
        }
        if (!("version" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["version"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClaudeSessionMessage instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ClaudeSessionMessage}
     */
    static createFrom($$source = {}) {
        const $$createField3_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("message" in $$parsedSource) {
            $$parsedSource["message"] = $$createField3_0($$parsedSource["message"]);
        }
        return new ClaudeSessionMessage(/** @type {Partial<ClaudeSessionMessage>} */($$parsedSource));
    }
}

/**
 * ClaudeSessionSummary represents aggregated session information
 * @Description Claude Code session summary with metrics and timing information
 */
export class ClaudeSessionSummary {
    /**
     * Creates a new ClaudeSessionSummary instance.
     * @param {Partial<ClaudeSessionSummary>} [$$source = {}] - The source object to create the ClaudeSessionSummary.
     */
    constructor($$source = {}) {
        if (!("worktreePath" in $$source)) {
            /**
             * Path to the worktree directory
             * @member
             * @type {string}
             */
            this["worktreePath"] = "";
        }
        if (!("sessionStartTime" in $$source)) {
            /**
             * When the current session started
             * @member
             * @type {time$0.Time | null}
             */
            this["sessionStartTime"] = null;
        }
        if (!("sessionEndTime" in $$source)) {
            /**
             * When the last session ended (if not active)
             * @member
             * @type {time$0.Time | null}
             */
            this["sessionEndTime"] = null;
        }
        if (!("turnCount" in $$source)) {
            /**
             * Number of conversation turns in the session
             * @member
             * @type {number}
             */
            this["turnCount"] = 0;
        }
        if (!("isActive" in $$source)) {
            /**
             * Whether this session is currently active
             * @member
             * @type {boolean}
             */
            this["isActive"] = false;
        }
        if (!("lastSessionId" in $$source)) {
            /**
             * ID of the most recent completed session
             * @member
             * @type {string | null}
             */
            this["lastSessionId"] = null;
        }
        if (/** @type {any} */(false)) {
            /**
             * ID of the currently active session
             * @member
             * @type {string | null | undefined}
             */
            this["currentSessionId"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * List of all available sessions for this worktree
             * @member
             * @type {SessionListEntry[] | undefined}
             */
            this["allSessions"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Header/title of the session from the Claude history
             * @member
             * @type {string | null | undefined}
             */
            this["header"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Metrics (from completed sessions)
             * Cost in USD of the last completed session
             * @member
             * @type {number | null | undefined}
             */
            this["lastCost"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Duration in seconds of the last session
             * @member
             * @type {number | null | undefined}
             */
            this["lastDuration"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Total input tokens used in the last session
             * @member
             * @type {number | null | undefined}
             */
            this["lastTotalInputTokens"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Total output tokens generated in the last session
             * @member
             * @type {number | null | undefined}
             */
            this["lastTotalOutputTokens"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClaudeSessionSummary instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ClaudeSessionSummary}
     */
    static createFrom($$source = {}) {
        const $$createField7_0 = $$createType2;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("allSessions" in $$parsedSource) {
            $$parsedSource["allSessions"] = $$createField7_0($$parsedSource["allSessions"]);
        }
        return new ClaudeSessionSummary(/** @type {Partial<ClaudeSessionSummary>} */($$parsedSource));
    }
}

/**
 * ClaudeSettings represents Claude configuration settings
 * @Description Claude Code configuration settings from ~/.claude.json
 */
export class ClaudeSettings {
    /**
     * Creates a new ClaudeSettings instance.
     * @param {Partial<ClaudeSettings>} [$$source = {}] - The source object to create the ClaudeSettings.
     */
    constructor($$source = {}) {
        if (!("theme" in $$source)) {
            /**
             * Current theme setting
             * @member
             * @type {string}
             */
            this["theme"] = "";
        }
        if (!("isAuthenticated" in $$source)) {
            /**
             * Whether user is authenticated (has userID)
             * @member
             * @type {boolean}
             */
            this["isAuthenticated"] = false;
        }
        if (/** @type {any} */(false)) {
            /**
             * Version string derived from lastReleaseNotesSeen
             * @member
             * @type {string | undefined}
             */
            this["version"] = undefined;
        }
        if (!("hasCompletedOnboarding" in $$source)) {
            /**
             * Whether user has completed onboarding
             * @member
             * @type {boolean}
             */
            this["hasCompletedOnboarding"] = false;
        }
        if (!("numStartups" in $$source)) {
            /**
             * Number of times Claude has been started
             * @member
             * @type {number}
             */
            this["numStartups"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClaudeSettings instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ClaudeSettings}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ClaudeSettings(/** @type {Partial<ClaudeSettings>} */($$parsedSource));
    }
}

/**
 * ClaudeSettingsUpdateRequest represents a request to update Claude settings
 * @Description Request to update Claude Code settings
 */
export class ClaudeSettingsUpdateRequest {
    /**
     * Creates a new ClaudeSettingsUpdateRequest instance.
     * @param {Partial<ClaudeSettingsUpdateRequest>} [$$source = {}] - The source object to create the ClaudeSettingsUpdateRequest.
     */
    constructor($$source = {}) {
        if (!("theme" in $$source)) {
            /**
             * Theme to set (must be one of the valid theme values)
             * @member
             * @type {string}
             */
            this["theme"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClaudeSettingsUpdateRequest instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ClaudeSettingsUpdateRequest}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ClaudeSettingsUpdateRequest(/** @type {Partial<ClaudeSettingsUpdateRequest>} */($$parsedSource));
    }
}

/**
 * CreateCompletionRequest represents a request to create a completion using claude CLI
 * @Description Request payload for Claude Code completion using claude CLI subprocess
 */
export class CreateCompletionRequest {
    /**
     * Creates a new CreateCompletionRequest instance.
     * @param {Partial<CreateCompletionRequest>} [$$source = {}] - The source object to create the CreateCompletionRequest.
     */
    constructor($$source = {}) {
        if (!("prompt" in $$source)) {
            /**
             * The prompt/message to send to claude
             * @member
             * @type {string}
             */
            this["prompt"] = "";
        }
        if (/** @type {any} */(false)) {
            /**
             * Whether to stream the response
             * @member
             * @type {boolean | undefined}
             */
            this["stream"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Optional system prompt override
             * @member
             * @type {string | undefined}
             */
            this["system_prompt"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Optional model override
             * @member
             * @type {string | undefined}
             */
            this["model"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Maximum number of turns in the conversation
             * @member
             * @type {number | undefined}
             */
            this["max_turns"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Working directory for the claude command
             * @member
             * @type {string | undefined}
             */
            this["working_directory"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Whether to resume the most recent session for this working directory
             * @member
             * @type {boolean | undefined}
             */
            this["resume"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CreateCompletionRequest instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {CreateCompletionRequest}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new CreateCompletionRequest(/** @type {Partial<CreateCompletionRequest>} */($$parsedSource));
    }
}

/**
 * CreateCompletionResponse represents a response from claude CLI completion
 * @Description Response from Claude Code completion using claude CLI subprocess
 */
export class CreateCompletionResponse {
    /**
     * Creates a new CreateCompletionResponse instance.
     * @param {Partial<CreateCompletionResponse>} [$$source = {}] - The source object to create the CreateCompletionResponse.
     */
    constructor($$source = {}) {
        if (!("response" in $$source)) {
            /**
             * The generated response text
             * @member
             * @type {string}
             */
            this["response"] = "";
        }
        if (/** @type {any} */(false)) {
            /**
             * Whether this is a streaming chunk or complete response
             * @member
             * @type {boolean | undefined}
             */
            this["is_chunk"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Whether this is the last chunk in a stream
             * @member
             * @type {boolean | undefined}
             */
            this["is_last"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Any error that occurred
             * @member
             * @type {string | undefined}
             */
            this["error"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CreateCompletionResponse instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {CreateCompletionResponse}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new CreateCompletionResponse(/** @type {Partial<CreateCompletionResponse>} */($$parsedSource));
    }
}

/**
 * FullSessionData represents complete session data including all messages
 * @Description Complete session data with all messages and metadata
 */
export class FullSessionData {
    /**
     * Creates a new FullSessionData instance.
     * @param {Partial<FullSessionData>} [$$source = {}] - The source object to create the FullSessionData.
     */
    constructor($$source = {}) {
        if (!("sessionInfo" in $$source)) {
            /**
             * Basic session information
             * @member
             * @type {ClaudeSessionSummary | null}
             */
            this["sessionInfo"] = null;
        }
        if (!("allSessions" in $$source)) {
            /**
             * All sessions available for this workspace
             * @member
             * @type {SessionListEntry[]}
             */
            this["allSessions"] = [];
        }
        if (/** @type {any} */(false)) {
            /**
             * Full conversation history (only when full=true)
             * @member
             * @type {ClaudeSessionMessage[] | undefined}
             */
            this["messages"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * User prompts from ~/.claude.json (only when full=true)
             * @member
             * @type {ClaudeHistoryEntry[] | undefined}
             */
            this["userPrompts"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Total message count in full data
             * @member
             * @type {number | undefined}
             */
            this["messageCount"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new FullSessionData instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {FullSessionData}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType4;
        const $$createField1_0 = $$createType2;
        const $$createField2_0 = $$createType6;
        const $$createField3_0 = $$createType8;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("sessionInfo" in $$parsedSource) {
            $$parsedSource["sessionInfo"] = $$createField0_0($$parsedSource["sessionInfo"]);
        }
        if ("allSessions" in $$parsedSource) {
            $$parsedSource["allSessions"] = $$createField1_0($$parsedSource["allSessions"]);
        }
        if ("messages" in $$parsedSource) {
            $$parsedSource["messages"] = $$createField2_0($$parsedSource["messages"]);
        }
        if ("userPrompts" in $$parsedSource) {
            $$parsedSource["userPrompts"] = $$createField3_0($$parsedSource["userPrompts"]);
        }
        return new FullSessionData(/** @type {Partial<FullSessionData>} */($$parsedSource));
    }
}

/**
 * GitStatus represents the current Git status
 * @Description Current git status including repository information
 */
export class GitStatus {
    /**
     * Creates a new GitStatus instance.
     * @param {Partial<GitStatus>} [$$source = {}] - The source object to create the GitStatus.
     */
    constructor($$source = {}) {
        if (!("repositories" in $$source)) {
            /**
             * All loaded repositories mapped by repository ID
             * @member
             * @type {{ [_: string]: Repository | null }}
             */
            this["repositories"] = {};
        }
        if (!("worktree_count" in $$source)) {
            /**
             * Total number of worktrees across all repositories
             * @member
             * @type {number}
             */
            this["worktree_count"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new GitStatus instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {GitStatus}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType11;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("repositories" in $$parsedSource) {
            $$parsedSource["repositories"] = $$createField0_0($$parsedSource["repositories"]);
        }
        return new GitStatus(/** @type {Partial<GitStatus>} */($$parsedSource));
    }
}

/**
 * Repository represents a Git repository
 * @Description Git repository information and metadata
 */
export class Repository {
    /**
     * Creates a new Repository instance.
     * @param {Partial<Repository>} [$$source = {}] - The source object to create the Repository.
     */
    constructor($$source = {}) {
        if (!("id" in $$source)) {
            /**
             * Repository identifier in owner/repo format
             * @member
             * @type {string}
             */
            this["id"] = "";
        }
        if (!("url" in $$source)) {
            /**
             * Full GitHub repository URL
             * @member
             * @type {string}
             */
            this["url"] = "";
        }
        if (!("path" in $$source)) {
            /**
             * Local path to the bare repository
             * @member
             * @type {string}
             */
            this["path"] = "";
        }
        if (!("default_branch" in $$source)) {
            /**
             * Default branch name for this repository
             * @member
             * @type {string}
             */
            this["default_branch"] = "";
        }
        if (!("available" in $$source)) {
            /**
             * Whether the repository is currently available on disk
             * @member
             * @type {boolean}
             */
            this["available"] = false;
        }
        if (!("created_at" in $$source)) {
            /**
             * When this repository was first cloned
             * @member
             * @type {time$0.Time}
             */
            this["created_at"] = null;
        }
        if (!("last_accessed" in $$source)) {
            /**
             * When this repository was last accessed
             * @member
             * @type {time$0.Time}
             */
            this["last_accessed"] = null;
        }
        if (!("description" in $$source)) {
            /**
             * Repository description
             * @member
             * @type {string}
             */
            this["description"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Repository instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {Repository}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Repository(/** @type {Partial<Repository>} */($$parsedSource));
    }
}

/**
 * SessionListEntry represents a single session in a list with basic metadata
 * @Description Session list entry with basic metadata
 */
export class SessionListEntry {
    /**
     * Creates a new SessionListEntry instance.
     * @param {Partial<SessionListEntry>} [$$source = {}] - The source object to create the SessionListEntry.
     */
    constructor($$source = {}) {
        if (!("sessionId" in $$source)) {
            /**
             * Unique session identifier
             * @member
             * @type {string}
             */
            this["sessionId"] = "";
        }
        if (!("lastModified" in $$source)) {
            /**
             * When the session was last modified
             * @member
             * @type {time$0.Time}
             */
            this["lastModified"] = null;
        }
        if (/** @type {any} */(false)) {
            /**
             * When the session started (if available)
             * @member
             * @type {time$0.Time | null | undefined}
             */
            this["startTime"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * When the session ended (if available)
             * @member
             * @type {time$0.Time | null | undefined}
             */
            this["endTime"] = undefined;
        }
        if (!("isActive" in $$source)) {
            /**
             * Whether this session is currently active
             * @member
             * @type {boolean}
             */
            this["isActive"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new SessionListEntry instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {SessionListEntry}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new SessionListEntry(/** @type {Partial<SessionListEntry>} */($$parsedSource));
    }
}

/**
 * TitleEntry represents a title with its timestamp and hash
 */
export class TitleEntry {
    /**
     * Creates a new TitleEntry instance.
     * @param {Partial<TitleEntry>} [$$source = {}] - The source object to create the TitleEntry.
     */
    constructor($$source = {}) {
        if (!("title" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["title"] = "";
        }
        if (!("timestamp" in $$source)) {
            /**
             * @member
             * @type {time$0.Time}
             */
            this["timestamp"] = null;
        }
        if (/** @type {any} */(false)) {
            /**
             * @member
             * @type {string | undefined}
             */
            this["commit_hash"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TitleEntry instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {TitleEntry}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TitleEntry(/** @type {Partial<TitleEntry>} */($$parsedSource));
    }
}

/**
 * Todo represents a single todo item from the TodoWrite tool
 * @Description A todo item with status and priority tracking
 */
export class Todo {
    /**
     * Creates a new Todo instance.
     * @param {Partial<Todo>} [$$source = {}] - The source object to create the Todo.
     */
    constructor($$source = {}) {
        if (!("id" in $$source)) {
            /**
             * Unique identifier for the todo item
             * @member
             * @type {string}
             */
            this["id"] = "";
        }
        if (!("content" in $$source)) {
            /**
             * The content/description of the todo
             * @member
             * @type {string}
             */
            this["content"] = "";
        }
        if (!("status" in $$source)) {
            /**
             * Current status of the todo
             * @member
             * @type {string}
             */
            this["status"] = "";
        }
        if (!("priority" in $$source)) {
            /**
             * Priority level of the todo
             * @member
             * @type {string}
             */
            this["priority"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Todo instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {Todo}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Todo(/** @type {Partial<Todo>} */($$parsedSource));
    }
}

/**
 * Worktree represents a Git worktree
 * @Description Git worktree with branch and status information
 */
export class Worktree {
    /**
     * Creates a new Worktree instance.
     * @param {Partial<Worktree>} [$$source = {}] - The source object to create the Worktree.
     */
    constructor($$source = {}) {
        if (!("id" in $$source)) {
            /**
             * Unique identifier for this worktree
             * @member
             * @type {string}
             */
            this["id"] = "";
        }
        if (!("repo_id" in $$source)) {
            /**
             * Repository this worktree belongs to
             * @member
             * @type {string}
             */
            this["repo_id"] = "";
        }
        if (!("name" in $$source)) {
            /**
             * User-friendly name for this worktree (e.g., 'vectorize-quasar')
             * @member
             * @type {string}
             */
            this["name"] = "";
        }
        if (!("path" in $$source)) {
            /**
             * Absolute path to the worktree directory
             * @member
             * @type {string}
             */
            this["path"] = "";
        }
        if (!("branch" in $$source)) {
            /**
             * Current git branch name in this worktree
             * @member
             * @type {string}
             */
            this["branch"] = "";
        }
        if (!("source_branch" in $$source)) {
            /**
             * Branch this worktree was originally created from
             * @member
             * @type {string}
             */
            this["source_branch"] = "";
        }
        if (!("has_been_renamed" in $$source)) {
            /**
             * Whether this worktree's branch has been renamed from its original catnip ref
             * @member
             * @type {boolean}
             */
            this["has_been_renamed"] = false;
        }
        if (!("commit_hash" in $$source)) {
            /**
             * Commit hash where this worktree diverged from source branch (updated after merges)
             * @member
             * @type {string}
             */
            this["commit_hash"] = "";
        }
        if (!("commit_count" in $$source)) {
            /**
             * Number of commits ahead of the divergence point (CommitHash)
             * @member
             * @type {number}
             */
            this["commit_count"] = 0;
        }
        if (!("commits_behind" in $$source)) {
            /**
             * Number of commits the source branch is ahead of our divergence point
             * @member
             * @type {number}
             */
            this["commits_behind"] = 0;
        }
        if (!("is_dirty" in $$source)) {
            /**
             * Whether there are uncommitted changes in the worktree
             * @member
             * @type {boolean}
             */
            this["is_dirty"] = false;
        }
        if (!("has_conflicts" in $$source)) {
            /**
             * Whether the worktree is in a conflicted state (rebase/merge conflicts)
             * @member
             * @type {boolean}
             */
            this["has_conflicts"] = false;
        }
        if (!("created_at" in $$source)) {
            /**
             * When this worktree was created
             * @member
             * @type {time$0.Time}
             */
            this["created_at"] = null;
        }
        if (!("last_accessed" in $$source)) {
            /**
             * When this worktree was last accessed
             * @member
             * @type {time$0.Time}
             */
            this["last_accessed"] = null;
        }
        if (/** @type {any} */(false)) {
            /**
             * Current session title (from terminal title escape sequences)
             * @member
             * @type {TitleEntry | null | undefined}
             */
            this["session_title"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * History of session titles
             * @member
             * @type {TitleEntry[] | undefined}
             */
            this["session_title_history"] = undefined;
        }
        if (!("has_active_claude_session" in $$source)) {
            /**
             * Whether there's an active Claude session for this worktree (deprecated - use ClaudeActivityState)
             * @member
             * @type {boolean}
             */
            this["has_active_claude_session"] = false;
        }
        if (!("claude_activity_state" in $$source)) {
            /**
             * Current Claude activity state (inactive/running/active)
             * @member
             * @type {ClaudeActivityState}
             */
            this["claude_activity_state"] = ClaudeActivityState.$zero;
        }
        if (/** @type {any} */(false)) {
            /**
             * URL of the associated pull request (if one exists)
             * @member
             * @type {string | undefined}
             */
            this["pull_request_url"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Title of the associated pull request (persisted for updates)
             * @member
             * @type {string | undefined}
             */
            this["pull_request_title"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Body/description of the associated pull request (persisted for updates)
             * @member
             * @type {string | undefined}
             */
            this["pull_request_body"] = undefined;
        }
        if (/** @type {any} */(false)) {
            /**
             * Current todos from the most recent TodoWrite in Claude session
             * @member
             * @type {Todo[] | undefined}
             */
            this["todos"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Worktree instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {Worktree}
     */
    static createFrom($$source = {}) {
        const $$createField14_0 = $$createType13;
        const $$createField15_0 = $$createType14;
        const $$createField21_0 = $$createType16;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("session_title" in $$parsedSource) {
            $$parsedSource["session_title"] = $$createField14_0($$parsedSource["session_title"]);
        }
        if ("session_title_history" in $$parsedSource) {
            $$parsedSource["session_title_history"] = $$createField15_0($$parsedSource["session_title_history"]);
        }
        if ("todos" in $$parsedSource) {
            $$parsedSource["todos"] = $$createField21_0($$parsedSource["todos"]);
        }
        return new Worktree(/** @type {Partial<Worktree>} */($$parsedSource));
    }
}

// Private type creation functions
const $$createType0 = $Create.Map($Create.Any, $Create.Any);
const $$createType1 = SessionListEntry.createFrom;
const $$createType2 = $Create.Array($$createType1);
const $$createType3 = ClaudeSessionSummary.createFrom;
const $$createType4 = $Create.Nullable($$createType3);
const $$createType5 = ClaudeSessionMessage.createFrom;
const $$createType6 = $Create.Array($$createType5);
const $$createType7 = ClaudeHistoryEntry.createFrom;
const $$createType8 = $Create.Array($$createType7);
const $$createType9 = Repository.createFrom;
const $$createType10 = $Create.Nullable($$createType9);
const $$createType11 = $Create.Map($Create.Any, $$createType10);
const $$createType12 = TitleEntry.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
const $$createType14 = $Create.Array($$createType12);
const $$createType15 = Todo.createFrom;
const $$createType16 = $Create.Array($$createType15);
