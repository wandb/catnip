//
//  MockPTYDataSource.swift
//  catnip
//
//  Mock PTY data source that replays captured session data
//  Used for Xcode previews and testing
//
//  Captures are generated using the Go tool: container/cmd/capture-pty
//

import Foundation
import Combine

// Data structures for PTY captures (generated by Go capture-pty tool)
struct CaptureMetadata: Codable {
    let captureDate: Date
    let totalBytes: Int
    let durationSeconds: Double
    let events: [CaptureEvent]
}

struct CaptureEvent: Codable {
    let timestampMs: Int
    let data: Data
}

class MockPTYDataSource: PTYDataSource {
    @Published private var _isConnected = false
    @Published private var _error: String?

    var isConnected: Published<Bool>.Publisher { $_isConnected }
    var error: Published<String?>.Publisher { $_error }

    var onData: ((Data) -> Void)?
    var onJSONMessage: ((PTYControlMessage) -> Void)?

    private let captureMetadata: CaptureMetadata
    private var replayTimer: Timer?
    private var currentEventIndex = 0
    private var replayStartTime: Date?
    private let playbackSpeed: Double

    enum LoadError: Error {
        case fileNotFound
        case invalidFormat
    }

    // Initialize with captured data file
    init(captureFile: String, playbackSpeed: Double = 1.0) throws {
        self.playbackSpeed = playbackSpeed

        // Load capture file from bundle
        guard let url = Bundle.main.url(forResource: captureFile, withExtension: "json") else {
            throw LoadError.fileNotFound
        }

        let data = try Data(contentsOf: url)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        self.captureMetadata = try decoder.decode(CaptureMetadata.self, from: data)

        NSLog("ðŸ“¼ Loaded PTY capture: %d bytes, %d events, %.2fs duration",
              captureMetadata.totalBytes,
              captureMetadata.events.count,
              captureMetadata.durationSeconds)
    }

    // Initialize with pre-loaded metadata (for testing)
    init(metadata: CaptureMetadata, playbackSpeed: Double = 1.0) {
        self.captureMetadata = metadata
        self.playbackSpeed = playbackSpeed
    }

    func connect() {
        NSLog("ðŸ“¼ Mock PTY: Connecting...")

        // Simulate connection delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { [weak self] in
            guard let self = self else { return }

            self._isConnected = true
            NSLog("ðŸ“¼ Mock PTY: Connected")
        }
    }

    func disconnect() {
        NSLog("ðŸ“¼ Mock PTY: Disconnecting...")

        replayTimer?.invalidate()
        replayTimer = nil
        currentEventIndex = 0
        replayStartTime = nil
        _isConnected = false

        NSLog("ðŸ“¼ Mock PTY: Disconnected")
    }

    func sendInput(_ text: String) {
        // Mock: just log input, don't actually send anywhere
        NSLog("ðŸ“¼ Mock PTY: Input: %@", text)
    }

    func sendResize(cols: UInt16, rows: UInt16) {
        NSLog("ðŸ“¼ Mock PTY: Resize: %dx%d", cols, rows)

        // Send mock buffer-size message
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
            let message = PTYControlMessage(
                type: "buffer-size",
                data: nil,
                submit: nil,
                cols: cols,
                rows: rows
            )
            self?.onJSONMessage?(message)
        }
    }

    func sendReady() {
        NSLog("ðŸ“¼ Mock PTY: Ready signal received, starting replay...")
        startReplay()
    }

    private func startReplay() {
        currentEventIndex = 0
        replayStartTime = Date()

        // Start timer to replay events at correct timing
        replayTimer = Timer.scheduledTimer(withTimeInterval: 0.016, repeats: true) { [weak self] _ in
            self?.replayNextEvents()
        }
    }

    private func replayNextEvents() {
        guard let replayStartTime = replayStartTime else { return }

        let elapsed = Date().timeIntervalSince(replayStartTime)
        let adjustedElapsed = elapsed * playbackSpeed
        let elapsedMs = Int(adjustedElapsed * 1000)

        // Replay all events up to current time
        while currentEventIndex < captureMetadata.events.count {
            let event = captureMetadata.events[currentEventIndex]

            // Check if this event should fire yet
            if event.timestampMs > elapsedMs {
                break
            }

            // Send the data
            onData?(event.data)
            currentEventIndex += 1

            // Check if we're done
            if currentEventIndex >= captureMetadata.events.count {
                NSLog("ðŸ“¼ Mock PTY: Replay complete")
                // Send buffer-complete message
                let message = PTYControlMessage(
                    type: "buffer-complete",
                    data: nil,
                    submit: nil,
                    cols: nil,
                    rows: nil
                )
                onJSONMessage?(message)

                replayTimer?.invalidate()
                replayTimer = nil
                break
            }
        }
    }
}
